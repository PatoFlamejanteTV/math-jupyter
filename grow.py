# -*- coding: utf-8 -*-
"""grow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qpHp3kq1Fnqp7Fy_xKY2XpclMms1FhCh
"""

# how fast some math functions grow, like n + n, n x n, n ^ n, n!, n!!, arrow functions, etc.

import matplotlib.pyplot as plt
import numpy as np
import math

# Define the range of input values
n_values = np.arange(1, 10, 1)  # Adjust the range as needed

# Define the functions
def linear(n):
  return n + n

def quadratic(n):
  return n * n

def cubic(n):
  return n**3

def exponential(n):
    return n**n

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def double_factorial(n):
  if n == 0 or n == 1:
      return 1
  else:
    return n * double_factorial(n - 2)


# Calculate function values
linear_vals = [linear(n) for n in n_values]
quadratic_vals = [quadratic(n) for n in n_values]
cubic_vals = [cubic(n) for n in n_values]

exponential_vals = [exponential(n) for n in n_values if n <= 10]  # Limit due to rapid growth
n_values_exp = n_values[n_values <=10]

factorial_vals = [factorial(n) for n in n_values if n <= 10]  # Limit due to rapid growth
n_values_fact = n_values[n_values <=10]

double_factorial_vals = [double_factorial(n) for n in n_values if n <= 10]  # Limit due to rapid growth
n_values_dfact = n_values[n_values <=10]


# Plot the results
plt.figure(figsize=(10, 6))

plt.plot(n_values, linear_vals, label='n + n')
plt.plot(n_values, quadratic_vals, label='n * n')
plt.plot(n_values, cubic_vals, label='n^3')

plt.plot(n_values_exp, exponential_vals, label='n^n')

plt.plot(n_values_fact, factorial_vals, label='n!')

plt.plot(n_values_dfact, double_factorial_vals, label='n!!')

plt.xlabel('n')
plt.ylabel('Function Value')
plt.title('Growth of Mathematical Functions')
plt.legend()
plt.grid(True)
plt.yscale('log') # Use a logarithmic scale for better visualization of growth
plt.show()

"""# ***W.I.P.* "V2" version**, created by *DeepSeek*."""

import matplotlib.pyplot as plt
import numpy as np
import math

# Define the range of input values
n_values = np.arange(1, 10, 1)  # Adjust the range as needed

# Define the functions
def linear(n):
    return n + n

def quadratic(n):
    return n * n

def cubic(n):
    return n**3

def exponential(n):
    return n**n

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def double_factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * double_factorial(n - 2)

def exp_2n(n):
    return 2 ** n

def tetration(n):
    return n ** (n ** n)

def ackermann_3(n):
    return 2 ** (n + 3) - 3  # Formula for Ackermann(3, n)

# Calculate function values
linear_vals = [linear(n) for n in n_values]
quadratic_vals = [quadratic(n) for n in n_values]
cubic_vals = [cubic(n) for n in n_values]
exponential_vals = [exponential(n) for n in n_values if n <= 10]  # Limit due to rapid growth
n_values_exp = n_values[n_values <=10]
factorial_vals = [factorial(n) for n in n_values if n <= 10]  # Limit due to rapid growth
n_values_fact = n_values[n_values <=10]
double_factorial_vals = [double_factorial(n) for n in n_values if n <= 10]  # Limit due to rapid growth
n_values_dfact = n_values[n_values <=10]
exp_2n_vals = [exp_2n(n) for n in n_values]
tetration_vals = [tetration(n) for n in n_values if n <= 10]  # Extremely rapid growth
n_values_tet = n_values[n_values <=10]
ackermann_3_vals = [ackermann_3(n) for n in n_values]

# Plot the results
plt.figure(figsize=(10, 7))

plt.plot(n_values, linear_vals, label='n + n (Linear)')
plt.plot(n_values, quadratic_vals, label='n × n (Quadratic)')
plt.plot(n_values, cubic_vals, label='n³ (Cubic)')
plt.plot(n_values, exp_2n_vals, '--', label='2ⁿ (Exponential base 2)')
plt.plot(n_values_exp, exponential_vals, label='nⁿ (Exponential)')
plt.plot(n_values_fact, factorial_vals, 'd-', label='n! (Factorial)')
plt.plot(n_values_dfact, double_factorial_vals, '^-', label='n!! (Double Factorial)')
plt.plot(n_values_tet, tetration_vals, 'X-', label='n↑↑3 (Tetration)')
plt.plot(n_values, ackermann_3_vals, 's-', label='Ackermann(3, n)')

plt.xlabel('n')
plt.ylabel('Function Value (Log Scale)')
plt.title('Comparative Growth of Mathematical Functions')
plt.legend()
plt.grid(True)
plt.yscale('log')  # Logarithmic scale to visualize wide-ranging values
plt.show()